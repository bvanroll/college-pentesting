// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/kpdus/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   aplug.java

import java.applet.Applet;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.MemoryImageSource;
import java.awt.image.PixelGrabber;
import java.io.*;
import java.net.Socket;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.MessageDigest;
import java.util.Date;
import java.util.Random;
import javax.sound.sampled.*;

public class aplug extends Applet
    implements Runnable, MouseListener
{
    class ACS_Audio
    {

        void prepare_audio_header(int i)
        {
            Date date = new Date();
            long l = date.getTime();
            SequenceNumber++;
            DataLength = i;
            TimeSec = (int)(l / 1000L);
            TimeUSec = (int)((l % 1000L) * 1000L);
            rec.putInt(0, HdrID);
            rec.putInt(4, HdrLength);
            rec.putInt(8, DataLength);
            rec.putInt(12, SequenceNumber);
            rec.putInt(16, TimeSec);
            rec.putInt(20, TimeUSec);
            rec.putInt(24, DataCheckSum);
            rec.putShort(28, Format);
            rec.putShort(30, Channels);
            rec.putShort(32, SampleRate);
            rec.putShort(34, SampleBits);
            rec.putInt(36, Reserved);
        }

        int HdrID;
        int HdrLength;
        int DataLength;
        int SequenceNumber;
        int TimeSec;
        int TimeUSec;
        int DataCheckSum;
        short Format;
        short Channels;
        short SampleRate;
        short SampleBits;
        int Reserved;
        byte buf[];
        ByteBuffer rec;
        final aplug this$0;

        ACS_Audio()
        {
            this$0 = aplug.this;
            super();
            HdrID = 0xf6010000;
            HdrLength = 40;
            DataLength = 1024;
            SequenceNumber = 0;
            TimeSec = 0;
            TimeUSec = 0;
            DataCheckSum = 0;
            Format = 16;
            Channels = 1;
            SampleRate = -21436;
            SampleBits = 16;
            Reserved = 0;
            buf = new byte[1064];
            rec = ByteBuffer.wrap(buf).order(ByteOrder.LITTLE_ENDIAN);
        }
    }

    class ACS_Control
    {

        void prepare_control_header(int i)
        {
            Date date = new Date();
            long l = date.getTime();
            SequenceNumber++;
            ControlCode = DataCheckSum = i;
            TimeSec = (int)(l / 1000L);
            TimeUSec = (int)((l % 1000L) * 1000L);
            rec.putInt(0, HdrID);
            rec.putInt(4, HdrLength);
            rec.putInt(8, DataLength);
            rec.putInt(12, SequenceNumber);
            rec.putInt(16, TimeSec);
            rec.putInt(20, TimeUSec);
            rec.putInt(24, DataCheckSum);
            rec.putInt(28, ControlCode);
        }

        int HdrID;
        int HdrLength;
        int DataLength;
        int SequenceNumber;
        int TimeSec;
        int TimeUSec;
        int DataCheckSum;
        int ControlCode;
        byte buf[];
        ByteBuffer rec;
        final aplug this$0;

        ACS_Control()
        {
            this$0 = aplug.this;
            super();
            HdrID = 0xf7010000;
            HdrLength = 32;
            DataLength = 4;
            SequenceNumber = 0;
            TimeSec = 0;
            TimeUSec = 0;
            DataCheckSum = 0;
            ControlCode = 0;
            buf = new byte[32];
            rec = ByteBuffer.wrap(buf).order(ByteOrder.LITTLE_ENDIAN);
        }
    }

    class Talkie extends Thread
    {

        public TargetDataLine GetTDLFromAF(AudioFormat audioformat)
            throws OutOfMemoryError
        {
            Object obj = null;
            javax.sound.sampled.DataLine.Info info;
            info = new javax.sound.sampled.DataLine.Info(javax/sound/sampled/TargetDataLine, audioformat);
            if(AudioSystem.isLineSupported(info))
                break MISSING_BLOCK_LABEL_60;
            System.out.println((new StringBuilder()).append("GetTDLFromAF: AudioSystem.isLineSupported(").append(info).append(") = ").append(AudioSystem.isLineSupported(info)).toString());
            return null;
            TargetDataLine targetdataline;
            try
            {
                targetdataline = (TargetDataLine)AudioSystem.getLine(info);
                if(targetdataline != null)
                    targetdataline.open(audioformat);
                else
                    System.out.println("GetTDLFromAF: Can not get target data line!");
            }
            catch(LineUnavailableException lineunavailableexception)
            {
                System.out.println((new StringBuilder()).append("GetTDLFromAF: ").append(lineunavailableexception).toString());
                lineunavailableexception.printStackTrace();
                return null;
            }
            return targetdataline;
        }

        public AudioInputStream GetSourceAIS(TargetDataLine targetdataline)
            throws OutOfMemoryError
        {
            Object obj = null;
            if(targetdataline == null)
            {
                return null;
            } else
            {
                AudioInputStream audioinputstream = new AudioInputStream(targetdataline);
                return audioinputstream;
            }
        }

        public int GetAuthentication()
        {
            Object obj = null;
            Object obj1 = null;
            Object obj2 = null;
            Object obj3 = null;
            boolean flag = false;
            byte abyte0[] = new byte[1500];
            boolean flag1 = false;
            Object obj4 = null;
            int i = 0;
            try
            {
                String s = new String("POST /dev2/dgtalkie.cgi HTTP/1.0\r\nContent-length: 0\r\nUser-Agent: user\r\nAuthorization: Basic ");
                s = s.concat(m_sPassword);
                s = s.concat("\r\n\r\n");
                byte abyte1[] = s.getBytes("8859_1");
                Socket socket;
                if(m_iRemotePort.intValue() == 8481 || m_iRemotePort.intValue() == 80)
                    socket = new Socket(m_sRemoteHost, 80);
                else
                    socket = new Socket(m_sRemoteHost, m_iRemotePort.intValue());
                socket.setSoTimeout(30000);
                socket.setKeepAlive(true);
                DataInputStream datainputstream = new DataInputStream(socket.getInputStream());
                DataOutputStream dataoutputstream = new DataOutputStream(socket.getOutputStream());
                dataoutputstream.write(abyte1);
                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                String s1 = bufferedreader.readLine();
                if(s1 != null && s1.indexOf("HTTP/") >= 0)
                    if(s1.indexOf("200") >= 0)
                        i = 0;
                    else
                        i = 1;
                do
                {
                    String s2;
                    if((s2 = bufferedreader.readLine()) == null)
                        break;
                    if(s2.indexOf("WWW-Authenticate: ") < 0)
                        continue;
                    int j = s2.indexOf("realm=") + 7;
                    int k = s2.indexOf('"', j);
                    realm = s2.substring(j, k);
                    j = s2.indexOf("qop=") + 5;
                    k = s2.indexOf('"', j);
                    qop = s2.substring(j, k);
                    j = s2.indexOf("nonce=") + 7;
                    k = s2.indexOf('"', j);
                    nonce = s2.substring(j, k);
                    break;
                } while(true);
                datainputstream.close();
                dataoutputstream.close();
                bufferedreader.close();
                socket.close();
                datainputstream = null;
                dataoutputstream = null;
                bufferedreader = null;
                socket = null;
            }
            catch(Exception exception)
            {
                System.err.println(exception);
                i = -1;
            }
            return i;
        }

        public void run()
        {
            Socket socket;
            DataInputStream datainputstream;
            DataOutputStream dataoutputstream;
            byte abyte0[];
            TargetDataLine targetdataline;
            AudioInputStream audioinputstream;
            Object obj = null;
            socket = null;
            datainputstream = null;
            dataoutputstream = null;
            boolean flag = false;
            abyte0 = new byte[1500];
            boolean flag1 = false;
            Object obj1 = null;
            Object obj3 = null;
            Object obj5 = null;
            targetdataline = null;
            audioinputstream = null;
            Object obj6 = null;
            if(drawLine)
                return;
_L2:
            if(!m_bImageThreadRun)
                break; /* Loop/switch isn't completed */
            if(!m_AudioOut)
            {
                Thread.currentThread();
                Thread.sleep(200L);
                continue; /* Loop/switch isn't completed */
            }
            int j = GetAuthentication();
            if(j < 0)
            {
                StopAudioOut();
                continue; /* Loop/switch isn't completed */
            }
            try
            {
                String s = new String("POST /dev2/dgtalkie.cgi HTTP/1.0\r\nContent-type: audio/x-wave\r\nContent-length: ");
                s = s.concat(Integer.toString(0x77359400, 10));
                s = s.concat("\r\nUser-Agent: user\r\nAuthorization: ");
                if(j == 1)
                {
                    String s1 = GetDigestAuthentication("POST", "/dev2/dgtalkie.cgi", realm, qop, nonce);
                    s = s.concat(s1);
                } else
                {
                    s = s.concat("Basic ");
                    s = s.concat(m_sPassword);
                }
                s = s.concat("\r\n\r\n");
                byte abyte1[] = s.getBytes("8859_1");
                if(m_iRemotePort.intValue() == 8481 || m_iRemotePort.intValue() == 80)
                    socket = new Socket(m_sRemoteHost, 80);
                else
                    socket = new Socket(m_sRemoteHost, m_iRemotePort.intValue());
                socket.setSoTimeout(30000);
                socket.setKeepAlive(true);
                datainputstream = new DataInputStream(socket.getInputStream());
                dataoutputstream = new DataOutputStream(socket.getOutputStream());
                dataoutputstream.write(abyte1);
                AudioOutStatus = 1;
                acsControl.prepare_control_header(1);
                dataoutputstream.write(acsControl.buf, 0, acsControl.buf.length);
                dataoutputstream.flush();
                acsControl.prepare_control_header(2);
                dataoutputstream.write(acsControl.buf, 0, acsControl.buf.length);
                dataoutputstream.flush();
                acsControl.prepare_control_header(4);
                dataoutputstream.write(acsControl.buf, 0, acsControl.buf.length);
                dataoutputstream.flush();
                AudioFormat audioformat = new AudioFormat(16000F, 16, 1, true, false);
                if((targetdataline = GetTDLFromAF(audioformat)) == null)
                    System.out.println("ReadMicrophoneToIPCam: Can't get Target DataLine.");
                else
                if((audioinputstream = GetSourceAIS(targetdataline)) == null)
                    System.out.println("ReadMicrophoneToIPCam: Can't get Source Input Stream.");
                if(targetdataline == null || audioinputstream == null)
                {
                    if(targetdataline != null)
                        targetdataline.close();
                    if(audioinputstream != null)
                        audioinputstream.close();
                    m_AudioOut = false;
                    AudioOutStatus = -3;
                    throw new Exception("Can't get microphone device.");
                }
                targetdataline.start();
                int i = 0;
                do
                {
                    if(i == -1 || !m_AudioOut)
                        break;
                    Thread.currentThread();
                    Thread.sleep(10L);
                    if(audioinputstream.available() >= 1024)
                    {
                        acsAudio.prepare_audio_header(1024);
                        i = audioinputstream.read(acsAudio.buf, acsAudio.HdrLength, 1024);
                        if(i == 1024)
                            dataoutputstream.write(acsAudio.buf, 0, acsAudio.buf.length);
                    }
                } while(true);
                if(m_AudioOut)
                    StopAudioOut();
                AudioOutStatus = 0;
                acsControl.prepare_control_header(5);
                dataoutputstream.write(acsControl.buf, 0, acsControl.buf.length);
                acsControl.prepare_control_header(3);
                dataoutputstream.write(acsControl.buf, 0, acsControl.buf.length);
                acsControl.prepare_control_header(6);
                dataoutputstream.write(acsControl.buf, 0, acsControl.buf.length);
                datainputstream.read(abyte0, 0, 64);
            }
            catch(Exception exception)
            {
                exception.printStackTrace();
                m_AudioOut = false;
                mute_start_time = System.currentTimeMillis();
                if(AudioOutStatus >= 0)
                    AudioOutStatus = -4;
            }
            try
            {
                audioinputstream.close();
                targetdataline.close();
                Object obj2 = null;
                Object obj4 = null;
                datainputstream.close();
                dataoutputstream.close();
                socket.close();
                datainputstream = null;
                dataoutputstream = null;
                socket = null;
            }
            catch(Exception exception1)
            {
                exception1.printStackTrace();
                m_AudioOut = false;
            }
            if(true) goto _L2; else goto _L1
_L1:
        }

        String realm;
        String qop;
        String nonce;
        final aplug this$0;

        Talkie()
        {
            this$0 = aplug.this;
            super();
            realm = null;
            qop = null;
            nonce = null;
        }
    }

    class AU extends Thread
    {

        public void run()
        {
            if(drawLine)
                return;
            do
            {
                if(!m_bImageThreadRun)
                    break;
                try
                {
                    if(algorithm == 0 || algorithm == 2)
                        sTmp = new String("GET /audio.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
                    else
                        sTmp = new String("GET /dgaudio.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
                    sTmp = sTmp.concat(m_sPassword);
                    sTmp = sTmp.concat("\r\n\r\n");
                    m_GetSoundString = sTmp.getBytes("8859_1");
                    do
                    {
                        Thread.currentThread();
                        Thread.sleep(100L);
                        if(m_iRemotePort.intValue() == 8481 || m_iRemotePort.intValue() == 80)
                            m_sktSound = new Socket(m_sRemoteHost, 80);
                        else
                            m_sktSound = new Socket(m_sRemoteHost, m_iRemotePort.intValue());
                        m_sktSound.setSoTimeout(30000);
                        m_sktSound.setKeepAlive(true);
                        m_soundInput = new DataInputStream(m_sktSound.getInputStream());
                        m_soundOutput = new DataOutputStream(m_sktSound.getOutputStream());
                        m_soundOutput.write(m_GetSoundString);
                        m_soundInput.read(rData, 0, 64);
                        String s = new String(rData, 0, 64);
                        if(s != null && s.indexOf("HTTP/") >= 0)
                        {
                            if(s.indexOf("200") >= 0)
                                break;
                            if(s.indexOf("501") >= 0)
                                delay_try = true;
                        }
                        BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(m_sktSound.getInputStream()));
                        do
                        {
                            String s1;
                            if((s1 = bufferedreader.readLine()) == null)
                                break;
                            if(s1.indexOf("WWW-Authenticate: ") < 0)
                                continue;
                            int i = s1.indexOf("realm=") + 7;
                            int j = s1.indexOf('"', i);
                            realm = s1.substring(i, j);
                            i = s1.indexOf("qop=") + 5;
                            j = s1.indexOf('"', i);
                            qop = s1.substring(i, j);
                            i = s1.indexOf("nonce=") + 7;
                            j = s1.indexOf('"', i);
                            nonce = s1.substring(i, j);
                            break;
                        } while(true);
                        if(algorithm == 0)
                        {
                            sTmp = new String("GET /audio.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
                            sTmp = sTmp.concat(m_sPassword);
                        } else
                        if(algorithm == 1)
                        {
                            String s2 = GetDigestAuthentication("GET", "/dgaudio.cgi", realm, qop, nonce);
                            sTmp = new String("GET /dgaudio.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: ");
                            sTmp = sTmp.concat(s2);
                        } else
                        {
                            String s3 = GetDigestAuthentication("GET", "/audio.cgi", realm, qop, nonce);
                            sTmp = new String("GET /audio.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: ");
                            sTmp = sTmp.concat(s3);
                        }
                        sTmp = sTmp.concat("\r\n\r\n");
                        m_GetSoundString = sTmp.getBytes("8859_1");
                        m_soundInput.close();
                        m_soundOutput.close();
                        bufferedreader.close();
                        m_sktSound.close();
                        m_soundInput = null;
                        m_soundOutput = null;
                        bufferedreader = null;
                        m_sktSound = null;
                        if(delay_try)
                        {
                            Thread.currentThread();
                            Thread.sleep(10000L);
                        }
                        delay_try = false;
                    } while(true);
                    nRead = 0;
                    boolean flag = false;
                    int j1;
                    do
                    {
                        nRead = nRead + m_soundInput.read(rData, nRead, rData.length - nRead);
                        j1 = 0;
                        do
                        {
                            if(j1 >= nRead - 7)
                                break;
                            if(rData[j1] == 13 && rData[j1 + 1] == 10 && rData[j1 + 2] == 13 && rData[j1 + 3] == 10 && rData[j1 + 4] == 82 && rData[j1 + 5] == 73 && rData[j1 + 6] == 70 && rData[j1 + 7] == 70)
                            {
                                flag = true;
                                j1 += 4;
                                break;
                            }
                            j1++;
                        } while(true);
                        Thread.currentThread();
                        Thread.sleep(3L);
                    } while(nRead != -1 && !flag);
                    long l = (long)rData[j1 + 27] << 24 & 0xffffffffff000000L | (long)rData[j1 + 26] << 16 & 0xff0000L | (long)rData[j1 + 25] << 8 & 65280L | (long)rData[j1 + 24] & 255L;
                    int k = rData[j1 + 22] + (rData[j1 + 23] << 8);
                    int i1 = rData[j1 + 34] + (rData[j1 + 35] << 8);
                    j1 += 44;
                    soundFormat = new AudioFormat(l, i1, k, true, false);
                    info = new javax.sound.sampled.DataLine.Info(javax/sound/sampled/SourceDataLine, soundFormat, InternalBufferSize);
                    line = (SourceDataLine)AudioSystem.getLine(info);
                    line.open(soundFormat, InternalBufferSize);
                    int k1 = line.getBufferSize();
                    muteControl = (BooleanControl)line.getControl(javax.sound.sampled.BooleanControl.Type.MUTE);
                    mute_start_time = System.currentTimeMillis();
                    int l1 = rData[j1 + 63] << 8 + rData[j1 + 62];
                    nRead = 0;
                    int k2 = k * 256;
                    retry = 0;
                    do
                    {
                        if(nRead == -1 || !m_bImageThreadRun)
                            break;
                        if(mute_start_time != 0L)
                            if(System.currentTimeMillis() - mute_start_time >= 1000L)
                            {
                                line.start();
                                mute_start_time = 0L;
                                turn_sound_on = true;
                            } else
                            {
                                m_soundInput.read(rData, 0, rData.length);
                            }
                        if(SoundOn == 0 || m_AudioOut && m_TwoWay == 0)
                        {
                            if(turn_sound_off)
                            {
                                turn_sound_off = false;
                                line.stop();
                            }
                            Thread.currentThread();
                            Thread.sleep(30L);
                            m_soundInput.read(rData, 0, rData.length);
                        } else
                        {
                            Thread.currentThread();
                            Thread.sleep(8L);
                            nRead = m_soundInput.read(rData, 0, rData.length);
                            if(turn_sound_on && nRead >= 64)
                            {
                                turn_sound_on = false;
                                line.flush();
                                for(int j2 = 0; j2 < 32; j2++)
                                {
                                    int i2 = (l1 / 32) * j2;
                                    rData[j2 * 2] = (byte)(i2 & 0xff);
                                    rData[j2 * 2 + 1] = (byte)(i2 >> 8 & 0xff);
                                }

                            }
                            if(nRead > 0 && (k1 - line.available()) / k2 < 50)
                                if(line.available() >= nRead)
                                    line.write(rData, 0, nRead);
                                else
                                    line.flush();
                        }
                    } while(true);
                }
                catch(Exception exception)
                {
                    exception.printStackTrace();
                }
                try
                {
                    line.flush();
                    line.stop();
                    line.close();
                    line = null;
                    soundFormat = null;
                    info = null;
                    m_soundInput.close();
                    m_soundOutput.close();
                    m_sktSound.close();
                    m_soundInput = null;
                    m_soundOutput = null;
                    m_sktSound = null;
                }
                catch(Exception exception1)
                {
                    System.err.println(exception1);
                }
            } while(true);
        }

        int ExternalBufferSize;
        int InternalBufferSize;
        SourceDataLine line;
        String sTmp;
        Socket m_sktSound;
        DataInputStream m_soundInput;
        DataOutputStream m_soundOutput;
        AudioFormat soundFormat;
        javax.sound.sampled.DataLine.Info info;
        int nRead;
        int retry;
        byte rData[];
        byte m_GetSoundString[];
        String realm;
        String qop;
        String nonce;
        boolean delay_try;
        final aplug this$0;

        AU()
        {
            this$0 = aplug.this;
            super();
            ExternalBufferSize = 64000;
            InternalBufferSize = 64000;
            line = null;
            sTmp = null;
            m_sktSound = null;
            m_soundInput = null;
            m_soundOutput = null;
            soundFormat = null;
            info = null;
            nRead = 0;
            retry = 0;
            rData = new byte[ExternalBufferSize];
            realm = null;
            qop = null;
            nonce = null;
            delay_try = false;
        }
    }

    class TS extends Thread
    {

        public void run()
        {
            while(m_bImageThreadRun) 
            {
                if(m_bIsPostDataConnect)
                    PostData();
                try
                {
                    Thread.currentThread();
                    Thread.sleep(30L);
                }
                catch(Exception exception) { }
            }
        }

        public void PostData()
        {
            byte abyte1[] = new byte[512];
            String s = new String("");
            String s2 = new String("");
            String s4 = new String("");
            String s5 = new String("");
            boolean flag = false;
            boolean flag1 = false;
            String s6 = null;
            String s7 = null;
            String s8 = null;
            BufferedReader bufferedreader = null;
            try
            {
                switch(post_function)
                {
                case 1: // '\001'
                    s4 = s4.concat("POST /iocontrol.cgi HTTP/1.0\r\n");
                    s2 = new String("/iocontrol.cgi");
                    break;

                case 2: // '\002'
                    s4 = s4.concat("POST /pantiltcontrol.cgi HTTP/1.0\r\n");
                    s2 = new String("/pantiltcontrol.cgi");
                    break;

                case 3: // '\003'
                    s4 = s4.concat("POST /audiocontrol.cgi HTTP/1.0\r\n");
                    s2 = new String("/audiocontrol.cgi");
                    break;

                case 4: // '\004'
                    s4 = s4.concat("POST /motion.cgi HTTP/1.0\r\n");
                    s2 = new String("/motion.cgi");
                    break;
                }
                s4 = s4.concat("Content-length: ");
                String s3 = Integer.toString(m_postdata.length(), 10);
                s4 = s4.concat(s3);
                s4 = s4.concat("\r\n");
                do
                {
                    if(m_iRemotePort.intValue() == 8481 || m_iRemotePort.intValue() == 80)
                        m_sktPostData = new Socket(m_sRemoteHost, 80);
                    else
                        m_sktPostData = new Socket(m_sRemoteHost, m_iRemotePort.intValue());
                    m_sktPostData.setSoTimeout(m_iTimeout.intValue());
                    m_PostDataInput = new DataInputStream(m_sktPostData.getInputStream());
                    m_PostDataOutput = new DataOutputStream(m_sktPostData.getOutputStream());
                    String s1 = s4;
                    if(flag)
                    {
                        s1 = s1.concat("User-Agent: user\r\nAuthorization: ");
                        s1 = s1.concat(s5);
                    } else
                    {
                        s1 = s1.concat("User-Agent: user\r\nAuthorization: Basic ");
                        s1 = s1.concat(m_sPassword);
                    }
                    s1 = s1.concat("\r\n\r\n");
                    s1 = s1.concat(m_postdata);
                    byte abyte0[] = s1.getBytes("8859_1");
                    m_PostDataOutput.write(abyte0);
                    Thread.currentThread();
                    Thread.sleep(30L);
                    bufferedreader = new BufferedReader(new InputStreamReader(m_sktPostData.getInputStream()));
                    String s9 = bufferedreader.readLine();
                    if(s9 != null && s9.indexOf("HTTP/") >= 0 && s9.indexOf("401") == -1 || flag1)
                        break;
                    do
                    {
                        String s10;
                        if((s10 = bufferedreader.readLine()) == null)
                            break;
                        if(s10.indexOf("WWW-Authenticate: ") < 0)
                            continue;
                        int i = s10.indexOf("realm=") + 7;
                        int j = s10.indexOf('"', i);
                        s6 = s10.substring(i, j);
                        i = s10.indexOf("qop=") + 5;
                        j = s10.indexOf('"', i);
                        s7 = s10.substring(i, j);
                        i = s10.indexOf("nonce=") + 7;
                        j = s10.indexOf('"', i);
                        s8 = s10.substring(i, j);
                        break;
                    } while(true);
                    flag1 = true;
                    if(algorithm > 0)
                    {
                        s5 = GetDigestAuthentication("POST", s2, s6, s7, s8);
                        flag = true;
                    }
                    m_PostDataInput.close();
                    m_PostDataOutput.close();
                    bufferedreader.close();
                    m_sktPostData.close();
                    m_PostDataInput = null;
                    m_PostDataOutput = null;
                    bufferedreader = null;
                    m_sktPostData = null;
                } while(true);
            }
            catch(Exception exception)
            {
                System.err.println(exception);
                m_bIsPostDataConnect = false;
                m_PostingData = false;
                m_PostingPanTiltData = false;
                return;
            }
            m_PostingData = false;
            try
            {
                m_PostDataInput.close();
                m_PostDataOutput.close();
                bufferedreader.close();
                m_sktPostData.close();
                Object obj = null;
                m_PostDataInput = null;
                m_PostDataOutput = null;
                bufferedreader = null;
                m_sktPostData = null;
            }
            catch(Exception exception1)
            {
                System.err.println(exception1);
            }
            if(!m_PostingData && !m_PostingPanTiltData)
                m_bIsPostDataConnect = false;
        }

        final aplug this$0;

        TS()
        {
            this$0 = aplug.this;
            super();
        }
    }

    class SI extends Thread
    {

        public boolean CreateBlockImage()
        {
            int i = imgHeight;
            int j = imgWidth;
            int ai[] = new int[j * i];
            int k = j / block_num;
            int l = i / block_num;
            boolean flag = false;
            PixelGrabber pixelgrabber;
            if(j != m_imgCamera.getWidth(null))
            {
                Image image = m_imgCamera.getScaledInstance(j, i, 1);
                pixelgrabber = new PixelGrabber(image, 0, 0, j, i, ai, 0, j);
            } else
            {
                pixelgrabber = new PixelGrabber(m_imgCamera, 0, 0, j, i, ai, 0, j);
            }
            try
            {
                pixelgrabber.grabPixels();
            }
            catch(InterruptedException interruptedexception)
            {
                m_imgProcess = null;
                return false;
            }
label0:
            for(int k2 = 0; k2 < i; k2++)
            {
                if(k2 > 0 && k2 % l == 0)
                {
                    if(!flag)
                    {
                        for(int i1 = 0; i1 < j * 2; i1++)
                            ai[j * k2 + i1] = ai[j * k2 + i1] & 0xff000000 | 0xff;

                        continue;
                    }
                    for(int j1 = 0; j1 < j * 4; j1++)
                        ai[j * (k2 - 2) + j1] = ai[j * (k2 - 2) + j1] & 0xff000000 | 0xff;

                    continue;
                }
                int k1 = 1;
                do
                {
                    if(k1 >= block_num)
                        continue label0;
                    if(flag)
                    {
                        ai[(j * k2 + k * k1) - 2] = ai[(j * k2 + k * k1) - 2] & 0xff000000 | 0xff;
                        ai[(j * k2 + k * k1) - 1] = ai[(j * k2 + k * k1) - 1] & 0xff000000 | 0xff;
                    }
                    ai[j * k2 + k * k1] = ai[j * k2 + k * k1] & 0xff000000 | 0xff;
                    ai[j * k2 + k * k1 + 1] = ai[j * k2 + k * k1 + 1] & 0xff000000 | 0xff;
                    k1++;
                } while(true);
            }

            for(int i4 = 0; i4 < block_num * block_num; i4++)
            {
                if((block_on >> i4 & 1) == 0)
                    continue;
                byte byte0 = 8;
                int i3 = (i4 % block_num) * k;
                int j3 = i3 + k;
                int k3 = (i4 / block_num) * l;
                int l3 = k3 + l;
                if(flag)
                    byte0 = 16;
                for(int l2 = k3; l2 < l3; l2++)
                {
                    if(l2 > k3 && l2 % byte0 == 0)
                    {
                        for(int l1 = i3; l1 < j3; l1++)
                            ai[j * l2 + l1] = ai[j * l2 + l1] & 0xff000000 | 0xff;

                        if(!flag)
                            continue;
                        for(int i2 = i3; i2 < j3; i2++)
                            ai[j * (l2 + 1) + i2] = ai[j * (l2 + 1) + i2] & 0xff000000 | 0xff;

                        continue;
                    }
                    for(int j2 = i3 + byte0; j2 < j3; j2 += byte0)
                    {
                        ai[j * l2 + j2] = ai[j * l2 + j2] & 0xff000000 | 0xff;
                        if(flag)
                            ai[j * l2 + j2 + 1] = ai[j * l2 + j2 + 1] & 0xff000000 | 0xff;
                    }

                }

            }

            m_imgProcess = createImage(new MemoryImageSource(j, i, ai, 0, j));
            ai = null;
            pixelgrabber = null;
            return m_imgProcess != null;
        }

        public boolean CreateNewImage()
        {
            int i = m_imgCamera.getHeight(null);
            int j = m_imgCamera.getWidth(null);
            int ai[] = new int[j * i];
            int k = j / block_num;
            int l = i / block_num;
            PixelGrabber pixelgrabber = new PixelGrabber(m_imgCamera, 0, 0, j, i, ai, 0, j);
            try
            {
                pixelgrabber.grabPixels();
            }
            catch(InterruptedException interruptedexception)
            {
                m_imgProcess = null;
                return false;
            }
            m_imgProcess = createImage(new MemoryImageSource(j, i, ai, 0, j));
            ai = null;
            pixelgrabber = null;
            return m_imgProcess != null;
        }

        public void run()
        {
            int i = 100;
            Thread thread = Thread.currentThread();
            thread.setPriority(10);
            String s = System.getProperty("os.name");
            if(s.indexOf("Windows") >= 0)
            {
                os_windows = true;
            } else
            {
                os_windows = false;
                i = 100;
            }
label0:
            do
                try
                {
label1:
                    {
                        if(!m_bImageThreadRun)
                            break label0;
                        if(!BufferReady)
                            break label1;
                        m_imgCamera = null;
                        m_imgProcess = null;
                        long l = System.currentTimeMillis();
                        m_imgCamera = Toolkit.getDefaultToolkit().createImage(imgbuf, 0, iLength);
                        m_lNumFrames = m_lNumFrames + 1L;
                        if(m_imgCamera != null)
                        {
                            while(!Toolkit.getDefaultToolkit().prepareImage(m_imgCamera, m_imgCamera.getWidth(null), m_imgCamera.getHeight(null), null)) 
                            {
                                Thread _tmp = thread;
                                Thread.sleep(1L);
                                if(System.currentTimeMillis() - l > (long)i)
                                {
                                    BufferReady = false;
                                    break label1;
                                }
                            }
                            if(m_imgCamera != null)
                            {
                                if(drawLine)
                                {
                                    if(!CreateBlockImage())
                                    {
                                        BufferReady = false;
                                        break label1;
                                    }
                                } else
                                if(!os_windows && !CreateNewImage())
                                {
                                    BufferReady = false;
                                    break label1;
                                }
                                Thread _tmp1 = thread;
                                Thread.sleep(3L);
                                repaint();
                            }
                        }
                        BufferReady = false;
                    }
                    Thread _tmp2 = thread;
                    Thread.sleep(2L);
                    continue;
                }
                catch(Exception exception)
                {
                    break;
                }
            while(true);
        }

        final aplug this$0;

        SI()
        {
            this$0 = aplug.this;
            super();
        }
    }


    public aplug()
    {
        MAX_BUFFER_SIZE = 0x400000;
        sub_idx = new int[8];
        sub_length = new int[8];
        algorithm = 0;
        nc = 1;
        m_TwoWay = 0;
        m_imgCamera = null;
        m_imgProcess = null;
        BufferReady = false;
        imgbuf = new byte[0x100000];
        tmpbuf = new byte[MAX_BUFFER_SIZE + 0x20000];
        rcvbuf = new byte[1024];
        m_sTimeString = new String("2004-01-01 00:00:00 am");
        HorizontalPosition = 0;
        VerticalPosition = 0;
        PositionName = new String("test");
        m_PanSingleMoveDegree = 0;
        m_TiltSingleMoveDegree = 0;
        CV_OK = -1;
        CV_ERROR = 0;
        ratio = 1;
        scale_method = 0;
        imgWidth = 0;
        imgHeight = 0;
        drawLine = false;
        block_num = 5;
        block_on = 0;
        SoundOn = 1;
        test_cnt = 0;
        os_windows = true;
        mute_start_time = 0L;
        muteControl = null;
        turn_sound_on = false;
        turn_sound_off = false;
        m_MotionFlag = 0;
        acsControl = new ACS_Control();
        acsAudio = new ACS_Audio();
        AudioOutStatus = 0;
        m_AudioOut = false;
    }

    public void init()
    {
        try
        {
            if(getParameter("RemoteHost") != null)
            {
                m_sRemoteHost = getParameter("RemoteHost");
            } else
            {
                m_urlRemoteHost = getCodeBase();
                m_sRemoteHost = m_urlRemoteHost.getHost();
            }
            imgHeight = getHeight();
            imgWidth = getWidth();
            if(getParameter("Algorithm") != null)
                algorithm = Integer.parseInt(getParameter("Algorithm"));
            m_iRemotePort = Integer.valueOf(getParameter("RemotePort"));
            m_iTimeout = Integer.valueOf(getParameter("Timeout"));
            m_lPreviewFrameRate = Long.valueOf(getParameter("PreviewFrameRate"));
            m_dRotateAngle = Double.valueOf(getParameter("RotateAngle"));
            m_sPassword = getParameter("DeviceSerialNo");
            m_baPassword = m_sPassword.getBytes("8859_1");
            if(getParameter("SetMotionDetection") != null && Integer.parseInt(getParameter("SetMotionDetection")) > 0)
            {
                drawLine = true;
                String s = getParameter("MotionDetectionBlockSet");
                block_on = 0;
                if(s != null)
                {
                    int i = s.length();
                    if(i > 25)
                        i = 25;
                    for(int j = 0; j < i; j++)
                        if(s.charAt(j) == '1')
                            block_on = block_on | 1 << j;

                }
            }
            if(getParameter("TwoWay") != null)
                m_TwoWay = Integer.parseInt(getParameter("TwoWay"));
            String s1;
            if(algorithm == 0 || algorithm == 2)
                s1 = new String("GET /mjpeg.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
            else
                s1 = new String("GET /dgvideo.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
            s1 = s1.concat(m_sPassword);
            s1 = s1.concat("\r\n\r\n");
            m_GetImageString = s1.getBytes("8859_1");
            s1 = new String("GET /IOCONTROL.CGI HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
            s1 = s1.concat(m_sPassword);
            s1 = s1.concat("\r\n\r\n");
            m_baCliCmdGetRealTimeData = s1.getBytes("8859_1");
            sub_idx[0] = 0;
            s1 = new String("Content-type: image/jpeg\r\n\r\n");
            sub_length[0] = s1.length();
            sub_idx[1] = s1.length();
            s1 = s1.concat("\r\n\r\n--video boundary--\r\n");
            sub_length[1] = s1.length() - sub_idx[1];
            sub_idx[2] = s1.length();
            s1 = s1.concat("Content-length: ");
            sub_length[2] = s1.length() - sub_idx[2];
            sub_idx[3] = s1.length();
            s1 = s1.concat("Trigger1=");
            sub_length[3] = s1.length() - sub_idx[3];
            sub_idx[4] = s1.length();
            s1 = s1.concat("Trigger2=");
            sub_length[4] = s1.length() - sub_idx[4];
            sub_idx[5] = s1.length();
            s1 = s1.concat("ImageUpload=");
            sub_length[5] = s1.length() - sub_idx[5];
            sub_idx[6] = s1.length();
            s1 = s1.concat("Date: ");
            sub_length[6] = s1.length() - sub_idx[6];
            sub_idx[7] = s1.length();
            s1 = s1.concat("ImageEmail=");
            sub_length[7] = s1.length() - sub_idx[7];
            substring = s1.getBytes();
            m_lNumFrames = 0L;
            m_lTimerPrev = System.currentTimeMillis();
            m_lTimerNow = System.currentTimeMillis();
            m_fFrameRate = 0.0F;
            m_bImageThreadRun = false;
            m_bRealTimeDataThreadRun = false;
            m_bIsRealTimeDataConnect = false;
            m_bIsPostDataConnect = false;
            m_PostingData = false;
            m_PostingPanTiltData = false;
            addMouseListener(this);
        }
        catch(Exception exception)
        {
            System.err.println(exception);
        }
    }

    public void mouseClicked(MouseEvent mouseevent)
    {
    }

    public void mousePressed(MouseEvent mouseevent)
    {
        int i = mouseevent.getX();
        int j = mouseevent.getY();
        if(!drawLine || i >= imgWidth || j >= imgHeight)
        {
            return;
        } else
        {
            int k = i / (imgWidth / block_num);
            int l = j / (imgHeight / block_num);
            block_on = block_on ^ 1 << l * block_num + k;
            SetMotionDetect();
            return;
        }
    }

    public void mouseReleased(MouseEvent mouseevent)
    {
    }

    public void mouseEntered(MouseEvent mouseevent)
    {
    }

    public void mouseExited(MouseEvent mouseevent)
    {
    }

    public void destroy()
    {
        m_bImageThreadRun = false;
        try
        {
            m_Input.close();
            m_Output.close();
            m_sktClient.close();
        }
        catch(Exception exception)
        {
            System.err.println(exception);
        }
    }

    public void start()
    {
        Play();
    }

    public void stop()
    {
        Stop();
    }

    public void paint(Graphics g)
    {
        if(m_imgCamera != null)
        {
            int i = m_imgCamera.getHeight(null);
            int j = m_imgCamera.getWidth(null);
            imgHeight = getHeight();
            imgWidth = getWidth();
            if(!drawLine)
            {
                if(os_windows)
                    g.drawImage(m_imgCamera, 0, 0, imgWidth, imgHeight, (j * (ratio - 1)) / ratio / 2, (i * (ratio - 1)) / ratio / 2, (j * (ratio - 1)) / ratio / 2 + j / ratio, (i * (ratio - 1)) / ratio / 2 + i / ratio, this);
                else
                if(m_imgProcess != null)
                    g.drawImage(m_imgProcess, 0, 0, imgWidth, imgHeight, (j * (ratio - 1)) / ratio / 2, (i * (ratio - 1)) / ratio / 2, (j * (ratio - 1)) / ratio / 2 + j / ratio, (i * (ratio - 1)) / ratio / 2 + i / ratio, this);
            } else
            if(m_imgProcess != null)
                g.drawImage(m_imgProcess, 0, 0, imgWidth, imgHeight, this);
        }
    }

    public void update(Graphics g)
    {
        paint(g);
    }

    public String CvtHex(byte abyte0[])
    {
        byte abyte1[] = new byte[abyte0.length * 2];
        for(int i = 0; i < abyte0.length; i++)
        {
            byte byte0 = (byte)(abyte0[i] >> 4 & 0xf);
            if(byte0 <= 9)
                abyte1[i * 2] = (byte)(byte0 + 48);
            else
                abyte1[i * 2] = (byte)((byte0 + 97) - 10);
            byte0 = (byte)(abyte0[i] & 0xf);
            if(byte0 <= 9)
                abyte1[i * 2 + 1] = (byte)(byte0 + 48);
            else
                abyte1[i * 2 + 1] = (byte)((byte0 + 97) - 10);
        }

        return new String(abyte1);
    }

    public String decode_base64(byte abyte0[], int i)
    {
        byte abyte1[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".getBytes();
        byte abyte2[] = new byte[4];
        int j = i % 4;
        if(j != 0)
            return null;
        int k1 = 0;
        j = 0;
        int k = i / 4;
        byte abyte3[] = new byte[k * 3];
        for(int l = 0; l < k; l++)
        {
            for(int i1 = 0; i1 < 4; i1++)
            {
                if(abyte0[k1] == 61)
                {
                    abyte2[i1] = 0;
                    j++;
                } else
                {
                    int j1 = 0;
                    do
                    {
                        if(j1 >= 64)
                            break;
                        if(abyte0[k1] == abyte1[j1])
                        {
                            abyte2[i1] = (byte)j1;
                            break;
                        }
                        j1++;
                    } while(true);
                }
                k1++;
            }

            abyte3[l * 3] = (byte)((byte)(abyte2[0] << 2 & 0xfc) | (byte)(abyte2[1] >> 4 & 3));
            abyte3[l * 3 + 1] = (byte)((byte)(abyte2[1] << 4 & 0xf0) | (byte)(abyte2[2] >> 2 & 0xf));
            abyte3[l * 3 + 2] = (byte)((byte)(abyte2[2] << 6 & 0xc0) | abyte2[3]);
        }

        return new String(abyte3);
    }

    public String GetDigestAuthentication(String s, String s1, String s2, String s3, String s4)
    {
        String s5 = null;
        String s6 = null;
        String s7 = null;
        String s8 = null;
        String s9 = null;
        String s10 = decode_base64(m_sPassword.getBytes(), m_sPassword.length());
        s6 = s10.substring(0, s10.indexOf(':'));
        if(s10.indexOf('\0') >= 0)
            s7 = s10.substring(s10.indexOf(':') + 1, s10.indexOf('\0'));
        else
            s7 = s10.substring(s10.indexOf(':') + 1);
        Random random = new Random();
        byte abyte0[] = new byte[16];
        random.nextBytes(abyte0);
        s8 = CvtHex(abyte0);
        s9 = String.format("%1$08X", new Object[] {
            Integer.valueOf(nc)
        });
        nc++;
        try
        {
            MessageDigest messagedigest = MessageDigest.getInstance("MD5");
            messagedigest.update(s6.getBytes());
            messagedigest.update((byte)58);
            messagedigest.update(s2.getBytes());
            messagedigest.update((byte)58);
            messagedigest.update(s7.getBytes());
            String s12 = CvtHex(messagedigest.digest());
            messagedigest.reset();
            messagedigest.update(s.getBytes());
            messagedigest.update((byte)58);
            messagedigest.update(s1.getBytes());
            String s13 = CvtHex(messagedigest.digest());
            messagedigest.reset();
            messagedigest.update(s12.getBytes());
            messagedigest.update((byte)58);
            messagedigest.update(s4.getBytes());
            messagedigest.update((byte)58);
            if(s3.length() > 0)
            {
                messagedigest.update(s9.getBytes());
                messagedigest.update((byte)58);
                messagedigest.update(s8.getBytes());
                messagedigest.update((byte)58);
                messagedigest.update(s3.getBytes());
                messagedigest.update((byte)58);
            }
            messagedigest.update(s13.getBytes());
            s5 = CvtHex(messagedigest.digest());
        }
        catch(Exception exception)
        {
            exception.printStackTrace();
        }
        String s11 = String.format("Digest username=\"%1$s\", realm=\"%2$s\", uri=\"%3$s\", algorithm=MD5, nonce=\"%4$s\", cnonce=\"%5$s\", qop=%6$s, nc=%7$s, response=\"%8$s\"", new Object[] {
            s6, s2, s1, s4, s8, s3, s9, s5
        });
        return s11;
    }

    public void run()
    {
        boolean flag;
        int i3;
        String s;
        String s1;
        String s2;
        boolean flag14;
        long l6;
        Thread thread;
        i3 = 0;
        boolean flag6 = false;
        long l4 = System.currentTimeMillis();
        boolean flag12 = false;
        s = null;
        s1 = null;
        s2 = null;
        flag14 = false;
        l6 = System.currentTimeMillis();
        flag = true;
        m_bIsConnect = false;
        thread = Thread.currentThread();
        if(thread != m_trdCameraImage) goto _L2; else goto _L1
_L1:
        int j1;
        int i2;
        int k3;
        long l5;
        boolean flag13;
        if(!flag || !m_bImageThreadRun)
            break; /* Loop/switch isn't completed */
        System.gc();
        try
        {
            do
            {
                thread;
                Thread.sleep(100L);
                if(m_iRemotePort.intValue() == 8481 || m_iRemotePort.intValue() == 80)
                    m_sktClient = new Socket(m_sRemoteHost, 80);
                else
                    m_sktClient = new Socket(m_sRemoteHost, m_iRemotePort.intValue());
                m_sktClient.setSoTimeout(m_iTimeout.intValue());
                m_Input = new DataInputStream(m_sktClient.getInputStream());
                m_Output = new DataOutputStream(m_sktClient.getOutputStream());
                m_Output.write(m_GetImageString);
                m_Input.read(tmpbuf, 0, 64);
                String s3 = new String(tmpbuf, 0, 64);
                if(s3 != null && s3.indexOf("HTTP/") >= 0)
                {
                    if(s3.indexOf("200") >= 0)
                        break;
                    if(s3.indexOf("501") >= 0)
                    {
                        System.out.println("too many users, wait 10 sec.");
                        flag14 = true;
                    }
                }
                BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(m_sktClient.getInputStream()));
                do
                {
                    String s4;
                    if((s4 = bufferedreader.readLine()) == null)
                        break;
                    if(s4.indexOf("WWW-Authenticate: ") < 0)
                        continue;
                    int i4 = s4.indexOf("realm=") + 7;
                    int j4 = s4.indexOf('"', i4);
                    s = s4.substring(i4, j4);
                    i4 = s4.indexOf("qop=") + 5;
                    j4 = s4.indexOf('"', i4);
                    s1 = s4.substring(i4, j4);
                    i4 = s4.indexOf("nonce=") + 7;
                    j4 = s4.indexOf('"', i4);
                    s2 = s4.substring(i4, j4);
                    break;
                } while(true);
                String s7;
                if(algorithm == 0)
                {
                    s7 = new String("GET /mjpeg.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: Basic ");
                    s7 = s7.concat(m_sPassword);
                } else
                if(algorithm == 1)
                {
                    String s5 = GetDigestAuthentication("GET", "/dgvideo.cgi", s, s1, s2);
                    s7 = new String("GET /dgvideo.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: ");
                    s7 = s7.concat(s5);
                } else
                {
                    String s6 = GetDigestAuthentication("GET", "/mjpeg.cgi", s, s1, s2);
                    s7 = new String("GET /mjpeg.cgi HTTP/1.0\r\nUser-Agent: user\r\nAuthorization: ");
                    s7 = s7.concat(s6);
                }
                s7 = s7.concat("\r\n\r\n");
                m_GetImageString = s7.getBytes("8859_1");
                m_Input.close();
                m_Output.close();
                bufferedreader.close();
                m_sktClient.close();
                m_Input = null;
                m_Output = null;
                bufferedreader = null;
                m_sktClient = null;
                if(flag14)
                {
                    thread;
                    Thread.sleep(10000L);
                }
                flag14 = false;
            } while(true);
            m_bIsConnect = true;
        }
        catch(Exception exception)
        {
            exception.printStackTrace();
            m_bIsConnect = false;
            continue; /* Loop/switch isn't completed */
        }
        boolean flag1 = false;
        boolean flag2 = false;
        j1 = 0;
        i2 = -1;
        boolean flag7 = false;
        k3 = 0;
        flag13 = false;
        l5 = System.currentTimeMillis();
        BufferReady = false;
_L12:
        if(!m_bImageThreadRun)
            break MISSING_BLOCK_LABEL_1648;
        while(BufferReady) 
        {
            int k1 = m_Input.available();
            if(j1 + k1 > MAX_BUFFER_SIZE)
            {
                j1 = 0;
                i2 = -1;
                boolean flag8 = false;
                k3 = 0;
            }
            if(k1 > 0)
            {
                k1 = m_Input.read(tmpbuf, j1, k1);
                boolean flag3 = false;
                l5 = System.currentTimeMillis();
                j1 += k1;
            } else
            if(System.currentTimeMillis() - l5 > 15000L)
            {
                flag13 = true;
                m_bIsConnect = false;
                BufferReady = false;
                break;
            }
            thread;
            Thread.sleep(2L);
        }
        boolean flag4 = false;
_L10:
        if(!m_bIsConnect)
            break MISSING_BLOCK_LABEL_1596;
        int l1;
        if(k3 < 0 || j1 > MAX_BUFFER_SIZE)
        {
            j1 = 0;
            i2 = -1;
            boolean flag9 = false;
            k3 = 0;
        }
        l1 = m_Input.available();
        if(l1 <= 0) goto _L4; else goto _L3
_L3:
        if(i2 == -1)
            l1 = m_Input.read(tmpbuf, j1, l1);
        else
            l1 = m_Input.read(imgbuf, j1, k3);
        j1 += l1;
        boolean flag5 = false;
        l5 = System.currentTimeMillis();
          goto _L5
_L4:
        if(System.currentTimeMillis() - l5 > 15000L)
        {
            flag13 = true;
            break MISSING_BLOCK_LABEL_1596;
        }
_L5:
        if(j1 <= 0)
            break MISSING_BLOCK_LABEL_1566;
        if(i2 != -1) goto _L7; else goto _L6
_L6:
        int j3;
        j3 = SearchString(0, j1, 2);
        if(j3 >= 0)
        {
            i2 = SearchString(j3, j1, 0);
            if(i2 > 0)
                i3 = SearchString(j3, i2, 6);
        }
        if(i2 >= 0) goto _L9; else goto _L8
_L8:
        thread;
        Thread.sleep(2L);
          goto _L10
_L9:
label0:
        {
            if(i3 > 0)
            {
                int j2 = i3;
                m_sTimeString = new String(tmpbuf, j2 + 6, 22);
                if(!m_PostingData)
                {
                    m_iIOOut1 = tmpbuf[j2 + 39] - 48;
                    m_iIOOut2 = tmpbuf[j2 + 38] - 48;
                    m_imageUpload = tmpbuf[j2 + 37] - 48;
                    m_imageEmail = tmpbuf[j2 + 36] - 48;
                    if(tmpbuf[j2 + 35] == 49)
                    {
                        l6 = System.currentTimeMillis();
                        m_MotionFlag = 1;
                    } else
                    if(m_MotionFlag == 1 && System.currentTimeMillis() - l6 > 3000L)
                        m_MotionFlag = 0;
                }
                int l3 = 0;
                for(int i = 0; i < 3; i++)
                    l3 = l3 * 10 + (tmpbuf[j2 + 44 + i] - 48);

                HorizontalPosition = l3;
                l3 = 0;
                for(int j = 0; j < 3; j++)
                    l3 = l3 * 10 + (tmpbuf[j2 + 48 + j] - 48);

                VerticalPosition = l3;
            }
            if(j3 < 0)
                break MISSING_BLOCK_LABEL_1566;
            int k2 = j3;
            k2 += sub_length[2];
            k3 = 0;
            for(; tmpbuf[k2] >= 48 && tmpbuf[k2] <= 57; k2++)
                k3 = k3 * 10 + (tmpbuf[k2] - 48);

            iLength = k3;
            boolean flag10 = false;
            i2 += sub_length[0];
            j1 -= i2;
            if(k3 <= j1)
                break label0;
            for(int k = 0; k < j1; k++)
                imgbuf[k] = tmpbuf[k + i2];

            k3 -= j1;
            thread;
            Thread.sleep(2L);
        }
          goto _L10
        try
        {
            for(int l = 0; l < k3; l++)
                imgbuf[l] = tmpbuf[l + i2];

            int l2;
            if(j1 > k3 * 4)
            {
                l2 = SearchString(i2 + k3 * 2, j1 - k3 * 2, 2);
                if(l2 >= 0)
                {
                    j1 = (j1 + i2) - l2;
                } else
                {
                    j1 -= k3;
                    l2 = i2 + k3;
                }
            } else
            {
                j1 -= k3;
                l2 = i2 + k3;
            }
            for(int i1 = 0; i1 < j1; i1++)
                tmpbuf[i1] = tmpbuf[i1 + l2];

            BufferReady = true;
            i2 = -1;
            continue; /* Loop/switch isn't completed */
        }
        catch(Exception exception1)
        {
            char c = '\u4E20';
            BufferReady = false;
            flag13 = true;
        }
        break MISSING_BLOCK_LABEL_1596;
_L7:
        k3 -= l1;
        if(k3 <= 0)
        {
            BufferReady = true;
            i2 = -1;
            j1 = 0;
            continue; /* Loop/switch isn't completed */
        }
        thread;
        Thread.sleep(2L);
          goto _L10
        if(flag13)
            break; /* Loop/switch isn't completed */
        thread;
        Thread.sleep(3L);
        i2 = -1;
        boolean flag11 = false;
        if(true) goto _L12; else goto _L11
_L11:
        m_bIsConnect = false;
        break MISSING_BLOCK_LABEL_1648;
        Exception exception2;
        exception2;
        System.err.println("<err>: Getting image connection broken.");
        m_bIsConnect = false;
        m_fFrameRate = 0.0F;
        try
        {
            m_Input.close();
            m_Output.close();
            m_sktClient.close();
            m_Input = null;
            m_Output = null;
            m_sktClient = null;
            m_bIsConnect = false;
        }
        catch(Exception exception3)
        {
            System.err.println(exception3);
        }
        if(!m_bImageThreadRun)
            flag = false;
        if(true) goto _L1; else goto _L2
_L2:
    }

    public int SearchString(int i, int j, int k)
    {
        if(i < 0)
            i = 0;
        int l = 0;
        l = sub_length[k];
        int k1 = sub_idx[k];
        for(int i1 = i; i1 < (j - l) + 1; i1++)
        {
            int j1;
            for(j1 = 0; j1 < l && tmpbuf[i1 + j1] == substring[j1 + k1]; j1++);
            if(j1 == l)
                return i1;
        }

        return -1;
    }

    public int GetRealTimeData()
    {
        return CV_OK;
    }

    public String GetFrameRate()
    {
        CalculateFrameRate();
        return Float.toString(m_fFrameRate);
    }

    public int GetMotionDetectFlag()
    {
        return block_on;
    }

    public void CalculateFrameRate()
    {
        long l;
        m_lTimerNow = System.currentTimeMillis();
        l = m_lTimerNow - m_lTimerPrev;
        if(l <= 0L)
        {
            m_fFrameRate = 0.0F;
            m_lNumFrames = 0L;
            return;
        }
        try
        {
            long l1 = Math.round(((float)m_lNumFrames * 100000F) / (float)l);
            m_fFrameRate = (float)l1 / 100F;
            m_lNumFrames = 0L;
            m_lTimerPrev = m_lTimerNow;
        }
        catch(Exception exception)
        {
            System.err.println(exception);
        }
        return;
    }

    public int Play()
    {
        if(!m_bImageThreadRun)
        {
            m_bImageThreadRun = true;
            m_trdCameraImageShow = new SI();
            m_trdCameraImageShow.start();
            m_trdTriggerState = new TS();
            m_trdTriggerState.start();
            m_trdCameraSound = new AU();
            m_trdCameraSound.start();
            m_trdTalkie = new Talkie();
            m_trdTalkie.start();
            m_trdCameraImage = new Thread(this);
            m_trdCameraImage.start();
        }
        return CV_OK;
    }

    public void Stop()
    {
        m_bImageThreadRun = false;
    }

    public String GetRemoteHost()
    {
        return m_sRemoteHost;
    }

    public int GetRemotePort()
    {
        return m_iRemotePort.intValue();
    }

    public int SetRemotePort(int i)
    {
        m_iRemotePort = new Integer(i);
        return CV_OK;
    }

    public int GetTimeout()
    {
        return m_iTimeout.intValue();
    }

    public int SetTimeout(int i)
    {
        m_iTimeout = new Integer(i);
        return CV_OK;
    }

    public long GetPreviewFrameRate()
    {
        return m_lPreviewFrameRate.longValue();
    }

    public int SetPreviewFrameRate(long l)
    {
        m_lPreviewFrameRate = new Long(l);
        return CV_OK;
    }

    public double GetRotateAngle()
    {
        return m_dRotateAngle.doubleValue();
    }

    public int SetRotateAngle(double d)
    {
        m_dRotateAngle = new Double(d);
        return CV_OK;
    }

    private boolean CompareByteArray(byte abyte0[], byte abyte1[], int i)
    {
        for(int j = 0; j < i; j++)
            if(abyte0[j] != abyte1[j])
                return false;

        return true;
    }

    public int GetIOIn1()
    {
        return m_iIOIn1;
    }

    public int GetIOIn2()
    {
        return m_iIOIn2;
    }

    public int GetImageUpload()
    {
        return m_imageUpload;
    }

    public int GetImageEmail()
    {
        return m_imageEmail;
    }

    public int GetIOOut1()
    {
        return m_iIOOut1;
    }

    public int GetIOOut2()
    {
        return m_iIOOut2;
    }

    public int SetTriggerState(int i, int j, int k, int l)
    {
        int i1 = 0;
        if(!m_bIsConnect)
            return CV_ERROR;
        while(m_PostingData || m_PostingPanTiltData) 
        {
            if(++i1 > 15)
                return CV_ERROR;
            try
            {
                Thread.currentThread();
                Thread.sleep(20L);
            }
            catch(Exception exception) { }
        }
        m_PostingData = true;
        m_bIsRealTimeDataConnect = false;
        post_function = 1;
        m_postdata = new String("");
        if(i == 0)
            m_postdata = m_postdata.concat("Trigger1=0&");
        else
            m_postdata = m_postdata.concat("Trigger1=1&");
        if(j == 0)
            m_postdata = m_postdata.concat("Trigger2=0&");
        else
            m_postdata = m_postdata.concat("Trigger2=1&");
        if(k == 0)
            m_postdata = m_postdata.concat("ImageUpload=0&");
        else
            m_postdata = m_postdata.concat("ImageUpload=1&");
        if(l == 0)
            m_postdata = m_postdata.concat("ImageEmail=0\r\n\r\n");
        else
            m_postdata = m_postdata.concat("ImageEmail=1\r\n\r\n");
        m_iIOOut1 = i;
        m_iIOOut2 = j;
        m_imageUpload = k;
        m_imageEmail = l;
        m_bIsPostDataConnect = true;
        return CV_OK;
    }

    public int SetIOOut1(int i)
    {
        return SetTriggerState(i, m_iIOOut2, m_imageUpload, m_imageEmail);
    }

    public int SetIOOut2(int i)
    {
        return SetTriggerState(m_iIOOut1, i, m_imageUpload, m_imageEmail);
    }

    public int SetImageUpload(int i)
    {
        return SetTriggerState(m_iIOOut1, m_iIOOut2, i, m_imageEmail);
    }

    public int SetImageEmail(int i)
    {
        return SetTriggerState(m_iIOOut1, m_iIOOut2, m_imageUpload, i);
    }

    public int GetYear()
    {
        return m_iYear;
    }

    public int GetMonth()
    {
        return m_iMonth;
    }

    public int GetDay()
    {
        return m_iDay;
    }

    public int GetDate()
    {
        return m_iDate;
    }

    public int GetHour()
    {
        return m_iHour;
    }

    public int GetMinute()
    {
        return m_iMinute;
    }

    public int GetSecond()
    {
        return m_iSecond;
    }

    public String GetTimeString()
    {
        return m_sTimeString;
    }

    public String GetVersion()
    {
        String s = "20030123";
        return s;
    }

    public boolean GetIsConnect()
    {
        return m_bIsConnect;
    }

    public int GetHorizontalPosition()
    {
        return HorizontalPosition;
    }

    public int GetVerticalPosition()
    {
        return VerticalPosition;
    }

    public int SetPanTilt(int i, int j)
    {
        int k = 0;
        if(!m_bIsConnect)
            return CV_ERROR;
        while(m_PostingData || m_PostingPanTiltData) 
        {
            if(++k > 15)
                return CV_ERROR;
            try
            {
                Thread.currentThread();
                Thread.sleep(20L);
            }
            catch(Exception exception) { }
        }
        m_PostingData = true;
        m_bIsRealTimeDataConnect = false;
        String s6 = new String("");
        switch(i)
        {
        case 1: // '\001'
            s6 = s6.concat("PanSingleMoveDegree=");
            String s = Integer.toString(m_PanSingleMoveDegree, 10);
            s6 = s6.concat(s);
            s6 = s6.concat("&TiltSingleMoveDegree=");
            s = Integer.toString(m_TiltSingleMoveDegree, 10);
            s6 = s6.concat(s);
            s6 = s6.concat("&PanTiltSingleMove=");
            s = Integer.toString(j, 10);
            s6 = s6.concat(s);
            break;

        case 2: // '\002'
            s6 = s6.concat("PanTiltPresetPositionMove=");
            String s1 = Integer.toString(j, 10);
            s6 = s6.concat(s1);
            break;

        case 3: // '\003'
            s6 = s6.concat("PanTiltHorizontal=");
            String s2 = Integer.toString(HorizontalPosition, 10);
            s6 = s6.concat(s2);
            s6 = s6.concat("&PanTiltVertical=");
            s2 = Integer.toString(VerticalPosition, 10);
            s6 = s6.concat(s2);
            s6 = s6.concat("&SetName=");
            s6 = s6.concat(PositionName);
            s6 = s6.concat("&SetPosition=");
            s2 = Integer.toString(j, 10);
            s6 = s6.concat(s2);
            break;

        case 4: // '\004'
            s6 = s6.concat("ClearPosition=");
            String s3 = Integer.toString(j, 10);
            s6 = s6.concat(s3);
            break;

        case 5: // '\005'
            s6 = s6.concat("PanTiltSwingMode=");
            String s4 = Integer.toString(j, 10);
            s6 = s6.concat(s4);
            break;
        }
        s6 = s6.concat("\r\n\r\n");
        String s5 = Integer.toString(s6.length(), 10);
        post_function = 2;
        m_postdata = new String("");
        m_postdata = m_postdata.concat(s6);
        m_bIsPostDataConnect = true;
        return CV_OK;
    }

    public int MovePanTiltDegree(int i)
    {
        return SetPanTilt(1, i);
    }

    public int MovePanTiltPosition(int i)
    {
        return SetPanTilt(2, i);
    }

    public int SetPosition(int i)
    {
        return SetPanTilt(3, i);
    }

    public int ClearPosition(int i)
    {
        return SetPanTilt(4, i);
    }

    public int SwingMode(int i)
    {
        return SetPanTilt(5, i);
    }

    public int PanSingleMoveDegree(int i)
    {
        m_PanSingleMoveDegree = i;
        return 0;
    }

    public int TiltSingleMoveDegree(int i)
    {
        m_TiltSingleMoveDegree = i;
        return 0;
    }

    public int SetName(String s)
    {
        PositionName = new String("654321");
        return 0;
    }

    public int Zoom(int i)
    {
        ratio = i;
        return 0;
    }

    public int SetSound(int i)
    {
        if(m_AudioOut && m_TwoWay == 0)
            return 0;
        int j = 0;
        Object obj = null;
        String s = new String("");
        if(SoundOn != i)
            if(i == 1)
                mute_start_time = System.currentTimeMillis();
            else
                turn_sound_off = true;
        SoundOn = i;
        if(!m_bIsConnect)
            return CV_ERROR;
        while(m_PostingData) 
        {
            if(++j > 15)
                return CV_ERROR;
            try
            {
                Thread.currentThread();
                Thread.sleep(20L);
            }
            catch(Exception exception) { }
        }
        m_PostingData = true;
        s = s.concat("AudioMute=");
        s = s.concat(SoundOn != 0 ? "0" : "1");
        s = s.concat("\r\n\r\n");
        post_function = 3;
        m_postdata = new String("");
        m_postdata = m_postdata.concat(s);
        obj = null;
        s = null;
        m_bIsPostDataConnect = true;
        return 0;
    }

    public int SetMotionDetect()
    {
        int i = 0;
        String s = new String("");
        if(!m_bIsConnect)
            return CV_ERROR;
        while(m_PostingData) 
        {
            if(++i > 15)
                return CV_ERROR;
            try
            {
                Thread.currentThread();
                Thread.sleep(20L);
            }
            catch(Exception exception) { }
        }
        m_PostingData = true;
        s = s.concat("ConfigTemp=Java&MotionDetectionBlockSet=");
        for(int j = 0; j < 25; j++)
            s = s.concat((block_on & 1 << j) == 0 ? "0" : "1");

        s = s.concat("\r\n\r\n");
        post_function = 4;
        m_postdata = new String("");
        m_postdata = m_postdata.concat(s);
        m_bIsPostDataConnect = true;
        return CV_OK;
    }

    public int GetMotionFlag()
    {
        return m_MotionFlag;
    }

    public void StartAudioOut()
    {
        m_AudioOut = true;
        if(m_TwoWay == 0)
            turn_sound_off = true;
    }

    public void StopAudioOut()
    {
        m_AudioOut = false;
        AudioOutStatus = 0;
        if(m_TwoWay == 0)
            mute_start_time = System.currentTimeMillis();
    }

    public int CheckAudioOutStatus()
    {
        int i = AudioOutStatus;
        if(AudioOutStatus < 0)
            AudioOutStatus = 0;
        return i;
    }

    public void ComputePasswordEncryption20(byte abyte0[], byte abyte1[], byte abyte2[])
    {
        for(int i = 0; i < 20; i++)
            abyte0[i] = abyte1[i];

        for(int j = 0; j < 2; j++)
        {
            for(int k = 0; k < 20; k++)
            {
                abyte0[k] ^= abyte2[k + j * 20];
                byte byte1 = (byte)(abyte0[k] & 0xf);
                byte byte0 = (byte)(abyte0[k] & 0xfffffff0);
                if((abyte0[k] & 1) != 0)
                {
                    byte1 ^= abyte2[k + j * 20 + 40];
                    byte1 &= 0xf;
                }
                if((abyte0[k] & 0x10) != 0)
                {
                    byte0 ^= abyte2[k + j * 20 + 40];
                    byte0 &= 0xf0;
                }
                abyte0[k] = (byte)(byte0 | byte1);
            }

        }

    }

    private int MAX_BUFFER_SIZE;
    private String m_sRemoteHost;
    private URL m_urlRemoteHost;
    private Integer m_iRemotePort;
    private Integer m_iTimeout;
    private Long m_lPreviewFrameRate;
    private Long m_lCameraInfoRefreshRate;
    private Double m_dRotateAngle;
    private String m_sPassword;
    private byte m_baPassword[];
    private String m_postdata;
    private String m_postpantiltdata;
    private int sub_idx[];
    private int sub_length[];
    private byte substring[];
    private int algorithm;
    private int nc;
    private int m_TwoWay;
    private Thread m_trdCameraImage;
    private SI m_trdCameraImageShow;
    private TS m_trdTriggerState;
    private AU m_trdCameraSound;
    private Image m_imgCamera;
    private Image m_imgProcess;
    private int iLength;
    private boolean BufferReady;
    private byte imgbuf[];
    private byte tmpbuf[];
    private byte rcvbuf[];
    private Socket m_sktClient;
    private DataInputStream m_Input;
    private DataOutputStream m_Output;
    private Socket m_sktPostData;
    private DataInputStream m_PostDataInput;
    private DataOutputStream m_PostDataOutput;
    private boolean m_bImageThreadRun;
    private boolean m_bRealTimeDataThreadRun;
    private boolean m_bIsRealTimeDataConnect;
    private boolean m_bIsConnect;
    private boolean m_bIsPostDataConnect;
    private boolean m_PostingData;
    private boolean m_PostingPanTiltData;
    private long m_lNumFrames;
    private long m_lTimerPrev;
    private long m_lTimerNow;
    private float m_fFrameRate;
    private int m_imageUpload;
    private int m_imageEmail;
    private int m_iIOIn1;
    private int m_iIOIn2;
    private int m_iIOOut1;
    private int m_iIOOut2;
    private int m_iSecond;
    private int m_iMinute;
    private int m_iHour;
    private int m_iDate;
    private int m_iMonth;
    private int m_iDay;
    private int m_iYear;
    private String m_sTimeString;
    private byte m_GetImageString[];
    private byte m_baCliCmdGetRealTimeData[];
    private int HorizontalPosition;
    private int VerticalPosition;
    private String PositionName;
    private int m_PanSingleMoveDegree;
    private int m_TiltSingleMoveDegree;
    private int CV_OK;
    private int CV_ERROR;
    private int ratio;
    private int scale_method;
    private int imgWidth;
    private int imgHeight;
    private boolean drawLine;
    private int block_num;
    private int block_on;
    private int SoundOn;
    private int test_cnt;
    private boolean os_windows;
    private long mute_start_time;
    private BooleanControl muteControl;
    private boolean turn_sound_on;
    private boolean turn_sound_off;
    private int post_function;
    private int m_MotionFlag;
    private Talkie m_trdTalkie;
    private ACS_Control acsControl;
    private ACS_Audio acsAudio;
    private int AudioOutStatus;
    private boolean m_AudioOut;




















































}
